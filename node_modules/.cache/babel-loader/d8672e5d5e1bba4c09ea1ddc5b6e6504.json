{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Yuvraj\\\\Pictures\\\\Stolenwork\\\\algo-visualizer\\\\src\\\\components\\\\GraphComponents\\\\Canvas.js\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport React from \"react\";\nimport Edge from \"./Edge\";\nimport Vertex from \"./Vertex\";\nimport DfsVisualization from \"../../algorithms/DFS/DfsVisualization\";\nimport BfsVisualization from \"../../algorithms/BFS/BfsVisualization\";\nimport KruskalVisualization from \"../../algorithms/Kruskal/KruskalVisualization\";\nimport PrimVisualization from \"../../algorithms/Prim/PrimVisualization\";\nimport DijkstraVisualization from \"../../algorithms/Dijkstra/DijkstraVisualization\";\nimport TopologicalSortVisualization from \"../../algorithms/TopologicalSort/TopologicalSortVisualization\";\nimport AdjList from \"../AdjList/AdjList\";\nimport TopoModal from \"../TopoModal/TopoModal\";\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nclass Canvas extends React.Component {\n  constructor(props) {\n    super(props);\n    this.moveEdge = (vertexID, x, y) => {\n      for (var i = 0; i < this.adjList.get(vertexID).length; i++) {\n        const id = this.adjList.get(vertexID)[i];\n        this.edgeRefs.get(id).current.changePosition(vertexID, x, y);\n      }\n      if (this.directedTo.has(vertexID)) {\n        for (var i = 0; i < this.directedTo.get(vertexID).length; i++) {\n          const id = this.directedTo.get(vertexID)[i];\n          this.edgeRefs.get(id).current.changePosition(vertexID, x, y);\n        }\n      }\n    };\n    this.addVertex = () => {\n      var newVertices = this.state.vertices.map(vertex => vertex);\n      const newVertexRef = /*#__PURE__*/React.createRef();\n      const uniqueID = uuidv4();\n      newVertices.push(/*#__PURE__*/_jsxDEV(Vertex, {\n        ref: newVertexRef,\n        vertexIndex: this.state.noOfVertices,\n        moveIncidentEdges: this.moveEdge,\n        uniqueID: uniqueID\n      }, uniqueID, false, {\n        fileName: _jsxFileName,\n        lineNumber: 51,\n        columnNumber: 7\n      }, this));\n      this.vertexIDs.push(uniqueID);\n      this.vertexRefs.set(uniqueID, newVertexRef);\n      this.adjList.set(uniqueID, []);\n      this.setState({\n        vertices: newVertices,\n        noOfVertices: this.state.noOfVertices + 1\n      });\n    };\n    this.isEdgePresent = (n1ID, n2ID, isDirected) => {\n      for (var i = 0; i < this.adjList.get(n1ID).length; i++) {\n        const edgeRef = this.edgeRefs.get(this.adjList.get(n1ID)[i]);\n        if (edgeRef.current.props.isDirected && edgeRef.current.n2ID === n2ID) {\n          return this.adjList.get(n1ID)[i];\n        }\n        if (!edgeRef.current.props.isDirected && (edgeRef.current.n1ID === n2ID || edgeRef.current.n2ID === n2ID)) {\n          return this.adjList.get(n1ID)[i];\n        }\n      }\n\n      // Directed edge from n2 to n1 exists and user trying to\n      // add Un-Directed edge from n1 to n2\n      if (!isDirected && this.directedTo.has(n1ID)) {\n        for (var i = 0; i < this.directedTo.get(n1ID).length; i++) {\n          const edgeRef = this.edgeRefs.get(this.directedTo.get(n1ID)[i]);\n          if (edgeRef.current.n1ID == n2ID) return this.directedTo.get(n1ID)[i];\n        }\n      }\n      return false;\n    };\n    // CASE 1 - Un-Directed edge from n1 to n2 exists\n    // Can NOT add any other edge between n1 and n2\n    // CASE 2 - Directed edge from n1 to n2 exists\n    // Can only add Directed edge from n2 to n1\n    // Can NOT add any Un- directed edge between n1 and n2\n    this.addEdge = (n1, n2, isDirected, weight) => {\n      const n1ID = this.vertexIDs[n1];\n      const n2ID = this.vertexIDs[n2];\n      if (this.isEdgePresent(n1ID, n2ID, isDirected) !== false) {\n        // console.log(\"edge already +nt\");\n        return;\n      }\n      const newEdgeRef = /*#__PURE__*/React.createRef();\n      const uniqueID = uuidv4();\n      var newEdges = this.state.edges.map(edge => edge);\n      newEdges.push(/*#__PURE__*/_jsxDEV(Edge, {\n        weight: weight,\n        ref: newEdgeRef,\n        n1Ref: this.vertexRefs.get(n1ID),\n        n2Ref: this.vertexRefs.get(n2ID),\n        edgeKey: uniqueID,\n        isDirected: isDirected\n      }, uniqueID, false, {\n        fileName: _jsxFileName,\n        lineNumber: 113,\n        columnNumber: 7\n      }, this));\n      this.edgeRefs.set(uniqueID, newEdgeRef);\n      this.adjList.get(n1ID).push(uniqueID);\n      if (!isDirected) this.adjList.get(n2ID).push(uniqueID);\n      if (isDirected) {\n        if (this.directedTo.has(n2ID)) this.directedTo.get(n2ID).push(uniqueID);else this.directedTo.set(n2ID, [uniqueID]);\n      }\n      this.setState({\n        edges: newEdges\n      });\n    };\n    this.clearCanvas = () => {\n      this.vertexIDs = [];\n      this.edgeRefs = new Map();\n      this.vertexRefs = new Map();\n      this.adjList = new Map();\n      this.directedTo = new Map();\n      this.setState({\n        visualize: false,\n        noOfVertices: 0,\n        vertices: [],\n        edges: [],\n        topoSort: []\n      });\n      this.props.visualizationEnd();\n    };\n    // check for optimisation\n    this.deleteVertex = vertexIndex => {\n      const uniqueID = this.vertexIDs[vertexIndex];\n      this.vertexRefs.delete(uniqueID);\n      const incidentEdges = this.adjList.get(uniqueID);\n      for (var i = 0; i < incidentEdges.length; i++) {\n        const edgeID = incidentEdges[i];\n        const edgeRef = this.edgeRefs.get(edgeID);\n        this.edgeRefs.delete(edgeID);\n        const connectedVertexID = edgeRef.current.getOtherVertexID(uniqueID);\n        if (edgeRef.current.props.isDirected) {\n          const updatedNeighbour = this.directedTo.get(connectedVertexID).filter(id => id !== edgeID);\n          this.directedTo.set(connectedVertexID, updatedNeighbour);\n        } else {\n          const updatedNeighbour = this.adjList.get(connectedVertexID).filter(id => id !== edgeID);\n          this.adjList.set(connectedVertexID, updatedNeighbour);\n        }\n      }\n      if (this.directedTo.has(uniqueID)) {\n        const incomingDirectedEdges = this.directedTo.get(uniqueID);\n        for (var i = 0; i < incomingDirectedEdges.length; i++) {\n          const edgeID = incomingDirectedEdges[i];\n          const edgeRef = this.edgeRefs.get(edgeID);\n          this.edgeRefs.delete(edgeID);\n          const connectedVertexID = edgeRef.current.getOtherVertexID(uniqueID);\n          const updatedNeighbour = this.adjList.get(connectedVertexID).filter(id => id !== edgeID);\n          this.adjList.set(connectedVertexID, updatedNeighbour);\n        }\n        this.directedTo.delete(uniqueID);\n      }\n      this.vertexIDs.splice(vertexIndex, 1);\n      this.adjList.delete(uniqueID);\n      for (i = vertexIndex; i < this.state.noOfVertices - 1; i++) {\n        const ind = this.vertexRefs.get(this.vertexIDs[i]).current.state.vertexIndex;\n        if (ind > vertexIndex) {\n          this.vertexRefs.get(this.vertexIDs[i]).current.changeVertexIndex(ind - 1);\n        }\n      }\n      this.setState({\n        noOfVertices: this.state.noOfVertices - 1,\n        vertices: this.state.vertices.filter(vertex => vertex.props.uniqueID !== uniqueID),\n        edges: this.state.edges.filter(edge => edge.props.n1Ref.current.id !== uniqueID && edge.props.n2Ref.current.id !== uniqueID)\n      });\n    };\n    this.deleteEdge = (n1, n2) => {\n      const n1ID = this.vertexIDs[n1];\n      const n2ID = this.vertexIDs[n2];\n      var toDeleteEdgeID = this.isEdgePresent(n1ID, n2ID, true);\n      if (toDeleteEdgeID === false) {\n        // console.log(\"edge NOT +nt\");\n        return;\n      }\n      const toDeleteEdgeRef = this.edgeRefs.get(toDeleteEdgeID);\n      this.edgeRefs.delete(toDeleteEdgeID);\n      const updated1Neighbour = this.adjList.get(n1ID).filter(edgeID => edgeID !== toDeleteEdgeID);\n      this.adjList.set(n1ID, updated1Neighbour);\n      if (toDeleteEdgeRef.current.props.isDirected === false) {\n        const updated2Neighbour = this.adjList.get(n2ID).filter(edgeID => edgeID !== toDeleteEdgeID);\n        this.adjList.set(n2ID, updated2Neighbour);\n      }\n      if (toDeleteEdgeRef.current.props.isDirected) {\n        const updated = this.directedTo.get(n2ID).filter(edgeID => edgeID !== toDeleteEdgeID);\n        this.directedTo.set(n2ID, updated);\n      }\n      this.setState({\n        edges: this.state.edges.filter(edge => edge.props.edgeKey !== toDeleteEdgeID)\n      });\n    };\n    // add code for getting starting vertex as input\n    this.startVisualizing = () => {\n      this.props.visualizationStart();\n    };\n    this.endVisualizing = () => {\n      this.props.visualizationEnd();\n    };\n    this.reset = () => {\n      this.vertexRefs.forEach(ref => ref.current.changeBackgroundColor(\"aqua\"));\n      this.edgeRefs.forEach(ref => ref.current.changeBackgroundColor(\"black\"));\n      this.props.visualizationEnd();\n    };\n    this.checkIfAllEdgesAreDirected = () => {\n      const adj = [...this.adjList.entries()];\n      for (var i = 0; i < adj.length; i++) {\n        const entry = adj[i][1];\n        for (var j = 0; j < entry.length; j++) {\n          const edgeRef = this.edgeRefs.get(entry[j]);\n          if (!edgeRef.current.props.isDirected) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    this.isCyclic = () => {\n      const vertexIndices = new Map();\n      const V = this.state.noOfVertices;\n      for (var i = 0; i < V; i++) {\n        vertexIndices.set(this.vertexIDs[i], i);\n      }\n      let visited = new Array(V).fill(false);\n      let recStack = new Array(V).fill(false);\n\n      // Call the recursive helper function to\n      // detect cycle in different DFS trees\n      for (let i = 0; i < V; i++) if (this.isCyclicUtil(this.vertexIDs[i], vertexIndices, visited, recStack)) return true;\n      return false;\n    };\n    this.isCyclicUtil = (vertexID, vertexIndices, visited, recStack) => {\n      var index = vertexIndices.get(vertexID);\n      if (!visited[index]) {\n        visited[index] = true;\n        recStack[index] = true;\n        const incidentEdges = this.adjList.get(vertexID);\n        const connectedVerticesID = incidentEdges.map(id => this.edgeRefs.get(id).current.getOtherVertexID(vertexID));\n        for (let c = 0; c < connectedVerticesID.length; c++) {\n          const otherIndex = vertexIndices.get(connectedVerticesID[c]);\n          if (!visited[otherIndex] && this.isCyclicUtil(connectedVerticesID[c], vertexIndices, visited, recStack)) return true;else if (recStack[otherIndex]) return true;\n        }\n        recStack[index] = false;\n        return false;\n      }\n    };\n    this.isGraphDAG = () => {\n      if (!this.checkIfAllEdgesAreDirected()) {\n        console.log(\"There are undirected edges in your graph\");\n        return false;\n      }\n      if (this.isCyclic()) {\n        console.log(\"There is a cycle in your graph\");\n        return false;\n      }\n      return true;\n    };\n    this.setTopoSort = array => {\n      const revArray = [];\n      for (var i = array.length - 1; i >= 0; i--) {\n        revArray.push(array[i]);\n      }\n\n      // console.log(revArray);\n\n      this.setState({\n        topoSort: revArray\n      });\n    };\n    this.vertexIDs = [];\n    this.edgeRefs = new Map();\n    this.vertexRefs = new Map();\n    this.adjList = new Map();\n    this.directedTo = new Map();\n\n    // this stores the directed edge incident TO a vertex\n    this.state = {\n      visualize: false,\n      noOfVertices: 0,\n      vertices: [],\n      edges: [],\n      topoSort: []\n    };\n  }\n  render() {\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"graph\",\n        children: [this.state.vertices, this.state.edges, this.props.isVisualizing && this.props.selectedAlgorithm === \"DFS\" ? /*#__PURE__*/_jsxDEV(DfsVisualization, {\n          startingVertex: parseInt(this.props.startNode),\n          noOfVertices: this.state.noOfVertices,\n          vertexIDs: this.vertexIDs,\n          vertexRefs: this.vertexRefs,\n          edgeRefs: this.edgeRefs,\n          adjList: this.adjList,\n          endVisualizing: this.endVisualizing,\n          visualizationSpeed: this.props.visualizationSpeed\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 385,\n          columnNumber: 13\n        }, this) : null, this.props.isVisualizing && this.props.selectedAlgorithm === \"BFS\" ? /*#__PURE__*/_jsxDEV(BfsVisualization, {\n          startingVertex: parseInt(this.props.startNode),\n          noOfVertices: this.state.noOfVertices,\n          vertexIDs: this.vertexIDs,\n          vertexRefs: this.vertexRefs,\n          edgeRefs: this.edgeRefs,\n          adjList: this.adjList,\n          endVisualizing: this.endVisualizing,\n          visualizationSpeed: this.props.visualizationSpeed\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 398,\n          columnNumber: 13\n        }, this) : null, this.props.isVisualizing && this.props.selectedAlgorithm === \"Kruskal MST\" ? /*#__PURE__*/_jsxDEV(KruskalVisualization, {\n          startingVertex: parseInt(this.props.startNode),\n          noOfVertices: this.state.noOfVertices,\n          vertexIDs: this.vertexIDs,\n          vertexRefs: this.vertexRefs,\n          edgeRefs: this.edgeRefs,\n          adjList: this.adjList,\n          endVisualizing: this.endVisualizing,\n          visualizationSpeed: this.props.visualizationSpeed\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 411,\n          columnNumber: 13\n        }, this) : null, this.props.isVisualizing && this.props.selectedAlgorithm === \"Prim MST\" ? /*#__PURE__*/_jsxDEV(PrimVisualization, {\n          startingVertex: parseInt(this.props.startNode),\n          noOfVertices: this.state.noOfVertices,\n          vertexIDs: this.vertexIDs,\n          vertexRefs: this.vertexRefs,\n          edgeRefs: this.edgeRefs,\n          adjList: this.adjList,\n          endVisualizing: this.endVisualizing,\n          visualizationSpeed: this.props.visualizationSpeed\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 424,\n          columnNumber: 13\n        }, this) : null, this.props.selectedAlgorithm === \"Dijkstra\" ? /*#__PURE__*/_jsxDEV(DijkstraVisualization, {\n          startingVertex: parseInt(this.props.startNode),\n          noOfVertices: this.state.noOfVertices,\n          vertexIDs: this.vertexIDs,\n          vertexRefs: this.vertexRefs,\n          edgeRefs: this.edgeRefs,\n          adjList: this.adjList,\n          endVisualizing: this.endVisualizing,\n          visualizationSpeed: this.props.visualizationSpeed,\n          isVisualizing: this.props.isVisualizing,\n          edges: this.state.edges\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 436,\n          columnNumber: 13\n        }, this) : null, this.props.isVisualizing && this.props.selectedAlgorithm === \"Topological Sort\" ? /*#__PURE__*/_jsxDEV(TopologicalSortVisualization, {\n          startingVertex: parseInt(this.props.startNode),\n          noOfVertices: this.state.noOfVertices,\n          vertexIDs: this.vertexIDs,\n          vertexRefs: this.vertexRefs,\n          edgeRefs: this.edgeRefs,\n          adjList: this.adjList,\n          endVisualizing: this.endVisualizing,\n          visualizationSpeed: this.props.visualizationSpeed,\n          setTopoModalOpen: this.props.setTopoModalOpen,\n          setTopoSort: this.setTopoSort\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 451,\n          columnNumber: 13\n        }, this) : null]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 380,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(AdjList, {\n        adjList: this.adjList,\n        nodeIndices: this.vertexIDs,\n        edgeRefs: this.edgeRefs,\n        open: this.props.open\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 465,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(TopoModal, {\n        topoSort: this.state.topoSort,\n        open: this.props.topoModalOpen,\n        setTopoModalOpen: this.props.setTopoModalOpen\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 471,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true);\n  }\n}\nexport default Canvas;","map":{"version":3,"names":["v4","uuidv4","React","Edge","Vertex","DfsVisualization","BfsVisualization","KruskalVisualization","PrimVisualization","DijkstraVisualization","TopologicalSortVisualization","AdjList","TopoModal","jsxDEV","_jsxDEV","Fragment","_Fragment","Canvas","Component","constructor","props","moveEdge","vertexID","x","y","i","adjList","get","length","id","edgeRefs","current","changePosition","directedTo","has","addVertex","newVertices","state","vertices","map","vertex","newVertexRef","createRef","uniqueID","push","ref","vertexIndex","noOfVertices","moveIncidentEdges","fileName","_jsxFileName","lineNumber","columnNumber","vertexIDs","vertexRefs","set","setState","isEdgePresent","n1ID","n2ID","isDirected","edgeRef","addEdge","n1","n2","weight","newEdgeRef","newEdges","edges","edge","n1Ref","n2Ref","edgeKey","clearCanvas","Map","visualize","topoSort","visualizationEnd","deleteVertex","delete","incidentEdges","edgeID","connectedVertexID","getOtherVertexID","updatedNeighbour","filter","incomingDirectedEdges","splice","ind","changeVertexIndex","deleteEdge","toDeleteEdgeID","toDeleteEdgeRef","updated1Neighbour","updated2Neighbour","updated","startVisualizing","visualizationStart","endVisualizing","reset","forEach","changeBackgroundColor","checkIfAllEdgesAreDirected","adj","entries","entry","j","isCyclic","vertexIndices","V","visited","Array","fill","recStack","isCyclicUtil","index","connectedVerticesID","c","otherIndex","isGraphDAG","console","log","setTopoSort","array","revArray","render","children","className","isVisualizing","selectedAlgorithm","startingVertex","parseInt","startNode","visualizationSpeed","setTopoModalOpen","nodeIndices","open","topoModalOpen"],"sources":["C:/Users/Yuvraj/Pictures/Stolenwork/algo-visualizer/src/components/GraphComponents/Canvas.js"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\r\nimport React from \"react\";\r\nimport Edge from \"./Edge\";\r\nimport Vertex from \"./Vertex\";\r\nimport DfsVisualization from \"../../algorithms/DFS/DfsVisualization\";\r\nimport BfsVisualization from \"../../algorithms/BFS/BfsVisualization\";\r\nimport KruskalVisualization from \"../../algorithms/Kruskal/KruskalVisualization\";\r\nimport PrimVisualization from \"../../algorithms/Prim/PrimVisualization\";\r\nimport DijkstraVisualization from \"../../algorithms/Dijkstra/DijkstraVisualization\";\r\nimport TopologicalSortVisualization from \"../../algorithms/TopologicalSort/TopologicalSortVisualization\";\r\nimport AdjList from \"../AdjList/AdjList\";\r\nimport TopoModal from \"../TopoModal/TopoModal\";\r\n\r\nclass Canvas extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.vertexIDs = [];\r\n    this.edgeRefs = new Map();\r\n    this.vertexRefs = new Map();\r\n    this.adjList = new Map();\r\n    this.directedTo = new Map();\r\n\r\n    // this stores the directed edge incident TO a vertex\r\n    this.state = {\r\n      visualize: false,\r\n      noOfVertices: 0,\r\n      vertices: [],\r\n      edges: [],\r\n      topoSort: [],\r\n    };\r\n  }\r\n\r\n  moveEdge = (vertexID, x, y) => {\r\n    for (var i = 0; i < this.adjList.get(vertexID).length; i++) {\r\n      const id = this.adjList.get(vertexID)[i];\r\n      this.edgeRefs.get(id).current.changePosition(vertexID, x, y);\r\n    }\r\n    if (this.directedTo.has(vertexID)) {\r\n      for (var i = 0; i < this.directedTo.get(vertexID).length; i++) {\r\n        const id = this.directedTo.get(vertexID)[i];\r\n        this.edgeRefs.get(id).current.changePosition(vertexID, x, y);\r\n      }\r\n    }\r\n  };\r\n\r\n  addVertex = () => {\r\n    var newVertices = this.state.vertices.map((vertex) => vertex);\r\n    const newVertexRef = React.createRef();\r\n    const uniqueID = uuidv4();\r\n    newVertices.push(\r\n      <Vertex\r\n        ref={newVertexRef}\r\n        vertexIndex={this.state.noOfVertices}\r\n        moveIncidentEdges={this.moveEdge}\r\n        uniqueID={uniqueID}\r\n        key={uniqueID}\r\n      />\r\n    );\r\n    this.vertexIDs.push(uniqueID);\r\n    this.vertexRefs.set(uniqueID, newVertexRef);\r\n    this.adjList.set(uniqueID, []);\r\n\r\n    this.setState({\r\n      vertices: newVertices,\r\n      noOfVertices: this.state.noOfVertices + 1,\r\n    });\r\n  };\r\n\r\n  isEdgePresent = (n1ID, n2ID, isDirected) => {\r\n    for (var i = 0; i < this.adjList.get(n1ID).length; i++) {\r\n      const edgeRef = this.edgeRefs.get(this.adjList.get(n1ID)[i]);\r\n      if (edgeRef.current.props.isDirected && edgeRef.current.n2ID === n2ID) {\r\n        return this.adjList.get(n1ID)[i];\r\n      }\r\n      if (\r\n        !edgeRef.current.props.isDirected &&\r\n        (edgeRef.current.n1ID === n2ID || edgeRef.current.n2ID === n2ID)\r\n      ) {\r\n        return this.adjList.get(n1ID)[i];\r\n      }\r\n    }\r\n\r\n    // Directed edge from n2 to n1 exists and user trying to\r\n    // add Un-Directed edge from n1 to n2\r\n    if (!isDirected && this.directedTo.has(n1ID)) {\r\n      for (var i = 0; i < this.directedTo.get(n1ID).length; i++) {\r\n        const edgeRef = this.edgeRefs.get(this.directedTo.get(n1ID)[i]);\r\n        if (edgeRef.current.n1ID == n2ID) return this.directedTo.get(n1ID)[i];\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n  // CASE 1 - Un-Directed edge from n1 to n2 exists\r\n  // Can NOT add any other edge between n1 and n2\r\n\r\n  // CASE 2 - Directed edge from n1 to n2 exists\r\n  // Can only add Directed edge from n2 to n1\r\n  // Can NOT add any Un- directed edge between n1 and n2\r\n\r\n  addEdge = (n1, n2, isDirected, weight) => {\r\n    const n1ID = this.vertexIDs[n1];\r\n    const n2ID = this.vertexIDs[n2];\r\n    if (this.isEdgePresent(n1ID, n2ID, isDirected) !== false) {\r\n      // console.log(\"edge already +nt\");\r\n      return;\r\n    }\r\n\r\n    const newEdgeRef = React.createRef();\r\n    const uniqueID = uuidv4();\r\n    var newEdges = this.state.edges.map((edge) => edge);\r\n\r\n    newEdges.push(\r\n      <Edge\r\n        weight={weight}\r\n        ref={newEdgeRef}\r\n        key={uniqueID}\r\n        n1Ref={this.vertexRefs.get(n1ID)}\r\n        n2Ref={this.vertexRefs.get(n2ID)}\r\n        edgeKey={uniqueID}\r\n        isDirected={isDirected}\r\n      />\r\n    );\r\n\r\n    this.edgeRefs.set(uniqueID, newEdgeRef);\r\n\r\n    this.adjList.get(n1ID).push(uniqueID);\r\n    if (!isDirected) this.adjList.get(n2ID).push(uniqueID);\r\n\r\n    if (isDirected) {\r\n      if (this.directedTo.has(n2ID)) this.directedTo.get(n2ID).push(uniqueID);\r\n      else this.directedTo.set(n2ID, [uniqueID]);\r\n    }\r\n\r\n    this.setState({\r\n      edges: newEdges,\r\n    });\r\n  };\r\n\r\n  clearCanvas = () => {\r\n    this.vertexIDs = [];\r\n    this.edgeRefs = new Map();\r\n    this.vertexRefs = new Map();\r\n    this.adjList = new Map();\r\n    this.directedTo = new Map();\r\n\r\n    this.setState({\r\n      visualize: false,\r\n      noOfVertices: 0,\r\n      vertices: [],\r\n      edges: [],\r\n      topoSort: [],\r\n    });\r\n    this.props.visualizationEnd();\r\n  };\r\n\r\n  // check for optimisation\r\n  deleteVertex = (vertexIndex) => {\r\n    const uniqueID = this.vertexIDs[vertexIndex];\r\n    this.vertexRefs.delete(uniqueID);\r\n\r\n    const incidentEdges = this.adjList.get(uniqueID);\r\n\r\n    for (var i = 0; i < incidentEdges.length; i++) {\r\n      const edgeID = incidentEdges[i];\r\n      const edgeRef = this.edgeRefs.get(edgeID);\r\n      this.edgeRefs.delete(edgeID);\r\n\r\n      const connectedVertexID = edgeRef.current.getOtherVertexID(uniqueID);\r\n\r\n      if (edgeRef.current.props.isDirected) {\r\n        const updatedNeighbour = this.directedTo\r\n          .get(connectedVertexID)\r\n          .filter((id) => id !== edgeID);\r\n\r\n        this.directedTo.set(connectedVertexID, updatedNeighbour);\r\n      } else {\r\n        const updatedNeighbour = this.adjList\r\n          .get(connectedVertexID)\r\n          .filter((id) => id !== edgeID);\r\n\r\n        this.adjList.set(connectedVertexID, updatedNeighbour);\r\n      }\r\n    }\r\n\r\n    if (this.directedTo.has(uniqueID)) {\r\n      const incomingDirectedEdges = this.directedTo.get(uniqueID);\r\n      for (var i = 0; i < incomingDirectedEdges.length; i++) {\r\n        const edgeID = incomingDirectedEdges[i];\r\n        const edgeRef = this.edgeRefs.get(edgeID);\r\n        this.edgeRefs.delete(edgeID);\r\n        const connectedVertexID = edgeRef.current.getOtherVertexID(uniqueID);\r\n\r\n        const updatedNeighbour = this.adjList\r\n          .get(connectedVertexID)\r\n          .filter((id) => id !== edgeID);\r\n\r\n        this.adjList.set(connectedVertexID, updatedNeighbour);\r\n      }\r\n      this.directedTo.delete(uniqueID);\r\n    }\r\n\r\n    this.vertexIDs.splice(vertexIndex, 1);\r\n    this.adjList.delete(uniqueID);\r\n\r\n    for (i = vertexIndex; i < this.state.noOfVertices - 1; i++) {\r\n      const ind = this.vertexRefs.get(this.vertexIDs[i]).current.state\r\n        .vertexIndex;\r\n      if (ind > vertexIndex) {\r\n        this.vertexRefs\r\n          .get(this.vertexIDs[i])\r\n          .current.changeVertexIndex(ind - 1);\r\n      }\r\n    }\r\n\r\n    this.setState({\r\n      noOfVertices: this.state.noOfVertices - 1,\r\n      vertices: this.state.vertices.filter(\r\n        (vertex) => vertex.props.uniqueID !== uniqueID\r\n      ),\r\n      edges: this.state.edges.filter(\r\n        (edge) =>\r\n          edge.props.n1Ref.current.id !== uniqueID &&\r\n          edge.props.n2Ref.current.id !== uniqueID\r\n      ),\r\n    });\r\n  };\r\n\r\n  deleteEdge = (n1, n2) => {\r\n    const n1ID = this.vertexIDs[n1];\r\n    const n2ID = this.vertexIDs[n2];\r\n\r\n    var toDeleteEdgeID = this.isEdgePresent(n1ID, n2ID, true);\r\n    if (toDeleteEdgeID === false) {\r\n      // console.log(\"edge NOT +nt\");\r\n      return;\r\n    }\r\n\r\n    const toDeleteEdgeRef = this.edgeRefs.get(toDeleteEdgeID);\r\n    this.edgeRefs.delete(toDeleteEdgeID);\r\n\r\n    const updated1Neighbour = this.adjList\r\n      .get(n1ID)\r\n      .filter((edgeID) => edgeID !== toDeleteEdgeID);\r\n    this.adjList.set(n1ID, updated1Neighbour);\r\n\r\n    if (toDeleteEdgeRef.current.props.isDirected === false) {\r\n      const updated2Neighbour = this.adjList\r\n        .get(n2ID)\r\n        .filter((edgeID) => edgeID !== toDeleteEdgeID);\r\n      this.adjList.set(n2ID, updated2Neighbour);\r\n    }\r\n\r\n    if (toDeleteEdgeRef.current.props.isDirected) {\r\n      const updated = this.directedTo\r\n        .get(n2ID)\r\n        .filter((edgeID) => edgeID !== toDeleteEdgeID);\r\n      this.directedTo.set(n2ID, updated);\r\n    }\r\n\r\n    this.setState({\r\n      edges: this.state.edges.filter(\r\n        (edge) => edge.props.edgeKey !== toDeleteEdgeID\r\n      ),\r\n    });\r\n  };\r\n\r\n  // add code for getting starting vertex as input\r\n  startVisualizing = () => {\r\n    this.props.visualizationStart();\r\n  };\r\n\r\n  endVisualizing = () => {\r\n    this.props.visualizationEnd();\r\n  };\r\n\r\n  reset = () => {\r\n    this.vertexRefs.forEach((ref) => ref.current.changeBackgroundColor(\"aqua\"));\r\n    this.edgeRefs.forEach((ref) => ref.current.changeBackgroundColor(\"black\"));\r\n    this.props.visualizationEnd();\r\n  };\r\n\r\n  checkIfAllEdgesAreDirected = () => {\r\n    const adj = [...this.adjList.entries()];\r\n\r\n    for (var i = 0; i < adj.length; i++) {\r\n      const entry = adj[i][1];\r\n      for (var j = 0; j < entry.length; j++) {\r\n        const edgeRef = this.edgeRefs.get(entry[j]);\r\n\r\n        if (!edgeRef.current.props.isDirected) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n\r\n  isCyclic = () => {\r\n    const vertexIndices = new Map();\r\n    const V = this.state.noOfVertices;\r\n    for (var i = 0; i < V; i++) {\r\n      vertexIndices.set(this.vertexIDs[i], i);\r\n    }\r\n\r\n    let visited = new Array(V).fill(false);\r\n    let recStack = new Array(V).fill(false);\r\n\r\n    // Call the recursive helper function to\r\n    // detect cycle in different DFS trees\r\n    for (let i = 0; i < V; i++)\r\n      if (\r\n        this.isCyclicUtil(this.vertexIDs[i], vertexIndices, visited, recStack)\r\n      )\r\n        return true;\r\n\r\n    return false;\r\n  };\r\n\r\n  isCyclicUtil = (vertexID, vertexIndices, visited, recStack) => {\r\n    var index = vertexIndices.get(vertexID);\r\n\r\n    if (!visited[index]) {\r\n      visited[index] = true;\r\n      recStack[index] = true;\r\n\r\n      const incidentEdges = this.adjList.get(vertexID);\r\n      const connectedVerticesID = incidentEdges.map((id) =>\r\n        this.edgeRefs.get(id).current.getOtherVertexID(vertexID)\r\n      );\r\n\r\n      for (let c = 0; c < connectedVerticesID.length; c++) {\r\n        const otherIndex = vertexIndices.get(connectedVerticesID[c]);\r\n\r\n        if (\r\n          !visited[otherIndex] &&\r\n          this.isCyclicUtil(\r\n            connectedVerticesID[c],\r\n            vertexIndices,\r\n            visited,\r\n            recStack\r\n          )\r\n        )\r\n          return true;\r\n        else if (recStack[otherIndex]) return true;\r\n      }\r\n      recStack[index] = false;\r\n      return false;\r\n    }\r\n  };\r\n\r\n  isGraphDAG = () => {\r\n    if (!this.checkIfAllEdgesAreDirected()) {\r\n      console.log(\"There are undirected edges in your graph\");\r\n      return false;\r\n    }\r\n\r\n    if (this.isCyclic()) {\r\n      console.log(\"There is a cycle in your graph\");\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  setTopoSort = (array) => {\r\n    const revArray = [];\r\n\r\n    for (var i = array.length - 1; i >= 0; i--) {\r\n      revArray.push(array[i]);\r\n    }\r\n\r\n    // console.log(revArray);\r\n\r\n    this.setState({ topoSort: revArray });\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <div className=\"graph\">\r\n          {this.state.vertices}\r\n          {this.state.edges}\r\n          {this.props.isVisualizing &&\r\n          this.props.selectedAlgorithm === \"DFS\" ? (\r\n            <DfsVisualization\r\n              startingVertex={parseInt(this.props.startNode)}\r\n              noOfVertices={this.state.noOfVertices}\r\n              vertexIDs={this.vertexIDs}\r\n              vertexRefs={this.vertexRefs}\r\n              edgeRefs={this.edgeRefs}\r\n              adjList={this.adjList}\r\n              endVisualizing={this.endVisualizing}\r\n              visualizationSpeed={this.props.visualizationSpeed}\r\n            />\r\n          ) : null}\r\n          {this.props.isVisualizing &&\r\n          this.props.selectedAlgorithm === \"BFS\" ? (\r\n            <BfsVisualization\r\n              startingVertex={parseInt(this.props.startNode)}\r\n              noOfVertices={this.state.noOfVertices}\r\n              vertexIDs={this.vertexIDs}\r\n              vertexRefs={this.vertexRefs}\r\n              edgeRefs={this.edgeRefs}\r\n              adjList={this.adjList}\r\n              endVisualizing={this.endVisualizing}\r\n              visualizationSpeed={this.props.visualizationSpeed}\r\n            />\r\n          ) : null}\r\n          {this.props.isVisualizing &&\r\n          this.props.selectedAlgorithm === \"Kruskal MST\" ? (\r\n            <KruskalVisualization\r\n              startingVertex={parseInt(this.props.startNode)}\r\n              noOfVertices={this.state.noOfVertices}\r\n              vertexIDs={this.vertexIDs}\r\n              vertexRefs={this.vertexRefs}\r\n              edgeRefs={this.edgeRefs}\r\n              adjList={this.adjList}\r\n              endVisualizing={this.endVisualizing}\r\n              visualizationSpeed={this.props.visualizationSpeed}\r\n            />\r\n          ) : null}\r\n          {this.props.isVisualizing &&\r\n          this.props.selectedAlgorithm === \"Prim MST\" ? (\r\n            <PrimVisualization\r\n              startingVertex={parseInt(this.props.startNode)}\r\n              noOfVertices={this.state.noOfVertices}\r\n              vertexIDs={this.vertexIDs}\r\n              vertexRefs={this.vertexRefs}\r\n              edgeRefs={this.edgeRefs}\r\n              adjList={this.adjList}\r\n              endVisualizing={this.endVisualizing}\r\n              visualizationSpeed={this.props.visualizationSpeed}\r\n            />\r\n          ) : null}\r\n          {this.props.selectedAlgorithm === \"Dijkstra\" ? (\r\n            <DijkstraVisualization\r\n              startingVertex={parseInt(this.props.startNode)}\r\n              noOfVertices={this.state.noOfVertices}\r\n              vertexIDs={this.vertexIDs}\r\n              vertexRefs={this.vertexRefs}\r\n              edgeRefs={this.edgeRefs}\r\n              adjList={this.adjList}\r\n              endVisualizing={this.endVisualizing}\r\n              visualizationSpeed={this.props.visualizationSpeed}\r\n              isVisualizing={this.props.isVisualizing}\r\n              edges={this.state.edges}\r\n            />\r\n          ) : null}\r\n          {this.props.isVisualizing &&\r\n          this.props.selectedAlgorithm === \"Topological Sort\" ? (\r\n            <TopologicalSortVisualization\r\n              startingVertex={parseInt(this.props.startNode)}\r\n              noOfVertices={this.state.noOfVertices}\r\n              vertexIDs={this.vertexIDs}\r\n              vertexRefs={this.vertexRefs}\r\n              edgeRefs={this.edgeRefs}\r\n              adjList={this.adjList}\r\n              endVisualizing={this.endVisualizing}\r\n              visualizationSpeed={this.props.visualizationSpeed}\r\n              setTopoModalOpen={this.props.setTopoModalOpen}\r\n              setTopoSort={this.setTopoSort}\r\n            />\r\n          ) : null}\r\n        </div>\r\n        <AdjList\r\n          adjList={this.adjList}\r\n          nodeIndices={this.vertexIDs}\r\n          edgeRefs={this.edgeRefs}\r\n          open={this.props.open}\r\n        ></AdjList>\r\n        <TopoModal\r\n          topoSort={this.state.topoSort}\r\n          open={this.props.topoModalOpen}\r\n          setTopoModalOpen={this.props.setTopoModalOpen}\r\n        ></TopoModal>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Canvas;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}